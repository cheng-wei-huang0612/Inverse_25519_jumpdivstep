#!/usr/bin/python3
import sys
import re
from math import log,ceil,floor,sqrt

def loadx4(s) :
    #print("%sx4 = 4x %s" % (s,s))
    print("%sx4 = stack%sx4" % (s,s))


#ni = 15 # the number of iterations per small loop
#loc_ur = 32
#loc_vs = 48
ni = 20 # the number of iterations per small loop
loc_ur = 41
loc_vs = 62
msk_fg = "_m2p%d" % (ni)
init_u = "_m2p%d" % (loc_ur)
init_s = "_m2p%d" % (loc_vs)
adj_ur = "_2p%d" % (loc_ur-ni-1)
adj_vs = "_2p%da2p%d" % (loc_ur-ni-1,loc_vs-ni-1)


const64s = { #msk_fg : - 2**ni,
             adj_ur : 2**(loc_ur-ni-1),
             #"_2p31":2147483648,
             init_u : -2**(loc_ur),
             init_s : -2**(loc_vs),
             adj_vs : 2**(loc_vs-ni-1) + 2**(loc_ur-ni-1)
}

def innerloops (ni) :
    for i in range(ni) :
        print('''# Rep #%d
  z = 0
  oldg = grs
  h = grs + fuv
              =? grs & 1

  z = m   if !=
  h = grs if  =
  mnew = m - 1
  grs -= fuv

  (int64) grs >>= 1
  (int64) h >>= 1
  m = ~m
                 signed<? z - 0

  fuv = oldg if  signed<
  grs = h    if !signed<
  m = mnew   if !signed<
#  (int64) grs >>= 1
''' % (i))

#def innerloop15 () :
#    for i in range(15) :
#        print('''# Rep #%d''' % (i))
#        if (i % 3 == 2) :
#            print("  z = 0")
#        else:
#            print("  z = stack_m1[1]")
#        print('''  
#  h = grs + fuv
##''')
#        if False :
#            print("  mnew = stack_m1[0]")
#        else:
#            print("  mnew = -1")
#        print('''  oldg = grs
#              =? grs & 1
#
#  h = grs if  =
#  z = m   if !=
#  mnew ^= m
#  grs -= fuv
#
#  (int64) h >>= 1
#  (int64) grs >>= 1
#  m -= 1
#                 signed<? z - 0
#
#  fuv = oldg if  signed<
#  grs = h    if !signed<
#  m = mnew   if  signed<
##  (int64) grs >>= 1
#''')

def extract() :
    print("  %s = stack%s" % (adj_vs,adj_vs))
    print("  s = grs + %s" % (adj_vs))
    print("  (int64) s >>= %d" % (loc_vs - ni))
    print('''
  t2 = g
  g *= s  
  # g = gs
''')
    print("  v = fuv + %s" % (adj_vs))
    print("  (int64) v >>= %d" % (loc_vs - ni))
    print('''
  t2 *= v
  # t2 = gv
''')
    print("  %s = stack%s" % (adj_ur,adj_ur))
    print("  r = grs + %s" % (adj_ur))
    print("  r <<= %d" % (63-loc_ur))
    print("  (int64) r >>= %d" % (63 - ni))
    print('''
      rax = f
      rax *= r
      # rax = fr
''')
    print("  u = fuv + %s" % (adj_ur))
    print("  u <<= %d" % (63-loc_ur))
    print("  (int64) u >>= %d" % (63 - ni))
    print('''
       f *= u
       f += t2
       g += rax
''')
    print("  (int64) f >>= %d\n  (int64) g >>= %d" % (ni,ni))

    
def store_uvrs() :
    print('''
  inplace stack_vvrr[0] = v
  inplace stack_uuss[0] = u
  inplace stack_uuss[2] = s
  inplace stack_vvrr[2] = r
''')

    
def next_fvgs(i,s) :
    print('''
FVGS%d = stack_FVGS%d 
GSFV%d = FVGS%d[1,0]
4x ta = int32 uuss1 * int32 FVGS%d
4x tb = int32 vvrr1 * int32 GSFV%d
4x out%dplus = ta + tb
4x ta = int32 uuss0 * int32 FVGS%d
4x tb = int32 vvrr0 * int32 GSFV%d
4x out%d = ta + tb
4x out%d += out%dplus
4x out%d += %s
''' % (i,i,i,i,i-1,i-1,i,i,i,i,i,i,i,s))

def carry_01(i,s) :
    print('''
4x d%d = int32 out%d * int32 _inv19_2p30x4
d%d &= _2p30m1x4
#4x %s = d%d << 15
4x d%dx19 = int32 d%d * int32 _19x4
4x out%d -= d%dx19
''' % (i,i,i,s,i,i,i,i,i))

def m2p33_srl30_p2p33(a,b) :
    print('''
4x %s = %s + _2p63m2p33x4 
4x %s unsigned>>= 30
''' % (b,a,b))

def m2p33_srl30_p2p33_mask30(a,b) :
    m2p33_srl30_p2p33(a,b)
    print("%s &= _2p30m1x4" % a)

def mask30_store(i) :
    print("out%d &= _2p30m1x4" % i)
    print("stack_FVGS%d = out%d" % (i-2,i))

print('''# Generated by cmovg.py
int64 m
int64 f
int64 g
int64 u
int64 v
int64 r
int64 s
int64 uvrs
int64 fuv
int64 grs
int64 mnew
int64 z
int64 loop
int64 rax
int64 rdx
int64 t0
int64 t1
int64 t2
int64 h
int64 oldg
int64 i
int64 j
int64 f0
int64 g0

int64 rtimesoldv
int64 stimesolds

stack64 stack_out

stack256 stack_m1
#stack64 stack_f   #inplace stack_fxgx[0] = f
#stack64 stack_g   #inplace stack_fxgx[2] = g
#stack64 stack_u   #inplace stack_uuss[0] = u
#stack64 stack_v   #inplace stack_vvrr[0] = v
#stack64 stack_r   #inplace stack_vvrr[2] = r
#stack64 stack_s   #inplace stack_uuss[2] = s
stack64 stack_m

stack256 stack_fxgx
stack256 stack_uuss
stack256 stack_vvrr
stack256 stack_fygy

stack64 stack_fuv
stack64 stack_f

reg256 carryy
reg256 carryz
reg256 d0
reg256 d1
reg256 d0x19
reg256 d1x19
reg256 out0
''')
for i in range(9) :
    print("reg256 FVGS%d\nreg256 GSFV%d" % (i,i))
    print("reg256 out%d\nreg256 out%dplus" % (i+1,i+1))
    print("stack256 stack_FVGS%d" % (i))
print('''
reg256 out8plus2
reg256 out10
reg256 ta
reg256 tb
reg256 uuss
reg256 uuss0
reg256 uuss1
reg256 vvrr
reg256 vvrr0
reg256 vvrr1
''')

# declare constants table
for s in const64s.keys() : print("int64 %17s\nstack64 %15s" % (s,"stack"+s))

intab256 = ["_19","_0_19","_32767","_inv19_2p30","_2p30m1","_2p33","_2p48","_2p63","_2p63m2p33"]
for i in range(len(intab256)) : print("reg256 %sx4" % (intab256[i]))
for i in range(len(intab256)) : print("stack256 stack%sx4" % (intab256[i]))

print('''
enter inverse_255
# input_0 = input
# input_1 = output
# input_2 = table of constants

new stack_m1
stack_out = input_1
''')

caller_saved = ["r11","r12","r13","r14","r15","rbx","rbp"]
for s in caller_saved :
    print("stack64 stack_%s\nstack_%s = caller_%s" % (s,s,s))

for i in range(4) :
    print("int64 a%d" % (i))
    print("a%d = mem64[input_0 + %2d]" % (i,8*i))
print('''
# a0 a1 a2 a3 between 0 and 2^256-1

t0 = a3
(int64) t0 >>= 63
a3 reset bit 63
t0 &= 19
t0 += 19
carry? a0 += t0
carry? a1 += 0 + carry
carry? a2 += 0 + carry
       a3 += 0 + carry

# a0 a1 a2 a3 between 19 and 2^255-1+38, offset by 19

t0 = a3
(int64) t0 >>= 63
a3 reset bit 63
t0 &= 19
carry? a0 += t0
carry? a1 += 0 + carry
carry? a2 += 0 + carry
       a3 += 0 + carry

# a0 a1 a2 a3 between 19 and 2^255-1, offset by 19

carry? a0 -= 19
carry? a1 -= 0 - carry
carry? a2 -= 0 - carry
       a3 -= 0 - carry

# a0 a1 a2 a3 between 0 and 2^255-19-1

t0 = -1152921504606846976
g = a0 & ~ t0
#g0 = a1
#g0 = (g0.a0) << 4
#g0 = g0 & ~ t0
''')

for i in range(8) :
    print("d1 = mem256[ input_2 + %3d ]"% (32*(len(intab256)+i)) )
    print("stack_FVGS%d = d1" % (i))
    limb_bot = (30*i) // 64
    limb_pos = (30*i) % 64
    limb_top = (30*i+29) // 64
    if (limb_bot == limb_top) :
        print("t0 = a%d" % (limb_bot))
        if (limb_pos > 0) :
            print("(uint64) t0 >>= %d" % (limb_pos))
        print("t0 &= 1073741823")
        print("inplace stack_FVGS%d[2] = t0" % (i))
    else:
        print("a%d = (a%d a%d) >> %d" % (limb_bot,limb_top,limb_bot,limb_pos))
        print("a%d &= 1073741823" % (limb_bot))
        print("inplace stack_FVGS%d[2] = a%d" % (i,limb_bot))
print("d1 = mem256[ input_2 + 544]")
print("stack_FVGS8 = d1")
limb_pos = (30*8) % 64
print("(uint64) a3 >>= %d" % (limb_pos))
print("inplace stack_FVGS8[2] = a3")
          
print('''
f = -19
#inplace stack_FVGS0[0] = f
#t1 = 32768
#inplace stack_FVGS8[0] = t1
#t0 = 1
#inplace stack_FVGS0[3] = t0

                 m = -1
                  z = 0
inplace stack_m1[0] = m
#                f0 = z
inplace stack_m1[1] = z
''')

for s in const64s.keys() :
    print("%19s = %d\n%19s = %s"%(s,const64s[s],"stack"+s,s))
print("")    
for i in range(len(intab256)) :
    print("%17sx4 = mem256[ input_2 + %3d ]" % (intab256[i],32*i))
    if (intab256[i] != "_2p63m2p33") :
        print("%17sx4 = %sx4" % ("stack"+intab256[i],intab256[i]))

print('''# idle loop
i = 12
u = 1152921504606846976
v = 0
s = u
r = 0
''')


print('''
bigloop:

# transition portion

      rax = g
      (int128) rdx rax = rax * s
      t2 = rax
      t1 = rdx

      rax = f
      (int128) rdx rax = rax * r
      carry? t2 += rax
             t1 += rdx + carry
      t2 = (t1 t2) >> 60	 

      rax = f
      (int128) rdx rax = rax * u
      f = rax
      t0 = rdx
      rax = g
      (int128) rdx rax = rax * v
      carry? f += rax
             t0 += rdx + carry
      f = (t0 f) >> 60

new vvrr
vvrr = v,vvrr[1],0,0
vvrr = vvrr[0],r,0,0

      v *= g0
      g0 *= s

      r *= f0
      f0 *= u
      f0 += v
      g0 += r

      f += f0
      g = t2+g0

# at this point new f and g are computed.

# startswap
FVGS0 = stack_FVGS0

new uuss
uuss = u,uuss[1],0,0
uuss = uuss[0],s,0,0

GSFV0 = FVGS0[1,0]

uuss = uuss[0,0,1,1]
vvrr = vvrr[0,0,1,1]

''')
loadx4("_2p30m1")
print('''
uuss0 = uuss & _2p30m1x4
vvrr0 = vvrr & _2p30m1x4
4x ta = int32 uuss0 * int32 FVGS0

4x tb = int32 vvrr0 * int32 GSFV0
4x out0 = ta + tb
''')
loadx4("_inv19_2p30")
loadx4("_19")
carry_01(0,"out8plus2")
#loadx4("_2p63")
print('''
4x carryy = out0 + stack_2p63x4
4x carryy unsigned>>= 30

4x out8plus2 = d0 << 15

FVGS1 = stack_FVGS1
GSFV1 = FVGS1[1,0]

4x ta = int32 uuss0 * int32 FVGS1
4x tb = int32 vvrr0 * int32 GSFV1
4x out1plus = ta + tb

4x uuss1 = uuss unsigned>> 30
4x vvrr1 = vvrr unsigned>> 30

4x ta = int32 uuss1 * int32 FVGS0
4x tb = int32 vvrr1 * int32 GSFV0
4x out1 = ta + tb
4x out1 += out1plus
4x out1 += carryy
''')
#next_fvgs(1)
carry_01(1,"out9")
#loadx4("_2p63m2p33")
m2p33_srl30_p2p33("out1","carryy")
print("4x out9 = d1 << 15")

next_fvgs(2,"carryy")
#m2p33_srl30_p2p33_mask30("out2","carryy")
m2p33_srl30_p2p33("out2","carryy")

next_fvgs(3,"carryy")
print("out2 &= _2p30m1x4")
m2p33_srl30_p2p33_mask30("out3","carryy")
print("stack_FVGS1 = out3")

print('''# store-ahead for f0 and g0
4x ta = out3 << 30
4x ta += out2
stack_fxgx = ta
''')

next_fvgs(4,"carryy")
#m2p33_srl30_p2p33_mask30("out4","carryy")
m2p33_srl30_p2p33("out4","carryy")

next_fvgs(5,"carryy")
#m2p33_srl30_p2p33_mask30("out5","carryy")
m2p33_srl30_p2p33_mask30("out5","carryy")
mask30_store(4)

print('''# store-ahead for f1 and g1
4x ta = out5 << 30
4x ta += out4
stack_fygy = ta
''')

next_fvgs(6,"carryy")
#m2p33_srl30_p2p33_mask30("out6","carryy")
m2p33_srl30_p2p33("out6","carryz")
print("stack_FVGS3 = out5")

next_fvgs(7,"carryz")
#m2p33_srl30_p2p33_mask30("out7","carryy")
m2p33_srl30_p2p33("out7","carryz")
mask30_store(6)

next_fvgs(8,"carryz")
print("4x out8 += out8plus2")
m2p33_srl30_p2p33("out8","carryz")
mask30_store(7)

print('''
4x ta = int32 uuss1 * int32 FVGS8
4x tb = int32 vvrr1 * int32 GSFV8
4x out9plus = ta + tb
4x out9 += out9plus
4x out9 += carryz
''')
m2p33_srl30_p2p33("out9","out10")

mask30_store(8)

loadx4("_32767")
loadx4("_2p48")
print('''
4x carryy = out10 + _2p63m2p33x4
4x carryy unsigned>>= 15
4x carryy -= _2p48x4
4x out10 -= stack_2p33x4

out9 &= _2p30m1x4

out10 &= _32767x4
4x carryy = int32 carryy * int32 stack_0_19x4

4x out2 += carryy
stack_FVGS7 = out9
stack_FVGS8 = out10
stack_FVGS0 = out2

#m = stack_m	     
#_m2p15 = stack_m2p15	

#f = stack_fxgx[0]
#g = stack_fxgx[2] 
''')

print('''
# entering condition: f and g are 60-bit signed ints

loop%d_init:

  #fuv = f & ~ %s
  #grs = g & ~ %s
  fuv = f
  grs = g
  fuv <<= %d
  grs <<= %d
  (int64) fuv >>= %d
  (int64) grs >>= %d
  fuv += stack%s
  grs += stack%s
''' % (ni,msk_fg,msk_fg,
       64-ni,64-ni,64-ni,64-ni,
       init_u,init_s))

innerloops(ni)

print('''
# extract u,v,r,s; compute next f,g
extract_init:
''')

extract()
store_uvrs()

print('''#  loop = 4
  #loop = 3
  loop = 2
# endswap

loop%d:

  #fuv = f & ~ %s
  #grs = g & ~ %s
  fuv = f
  grs = g
  fuv <<= %d
  grs <<= %d
  (int64) fuv >>= %d
  (int64) grs >>= %d
  fuv += stack%s
  grs += stack%s
''' % (ni,msk_fg,msk_fg,
       64-ni,64-ni,64-ni,64-ni,
       init_u,init_s))

print("j = 2")
print("loop2:")
innerloops(ni//2)
print(" =? j -= 1")
print("goto loop2 if !=")
print('''
  =? loop -= 1		
goto lastloop if =

# extract u,v,r,s
extract:
''')

extract()

print('''
#first loops iteration has NOT been removed
#=? loop - 2  
#goto first_loop if =

  t0 = stack_uuss[0]
  t0 *= u
  t1 = stack_vvrr[2]
  t1 *= v

  rtimesoldv = stack_vvrr[0]
  u *= rtimesoldv
  stimesolds = stack_uuss[2]
  v *= stimesolds
  rtimesoldv *= r
  stimesolds *= s
  r *= stack_uuss[0]
  s *= stack_vvrr[2]

  v += u
  u = t0 + t1

  r += s
  s = rtimesoldv + stimesolds

first_loop:
''')
store_uvrs()
print('''
goto loop%d 

lastloop:
''' % (ni))

print("  %s = stack%s" % (adj_vs,adj_vs))
print("  s = grs + %s" % (adj_vs))
print("  (int64) s >>= %d" % (loc_vs - ni))
print("  v = fuv + %s" % (adj_vs))
print("  (int64) v >>= %d" % (loc_vs - ni))
print('''
  t1 = stack_vvrr[2]
  t1 *= v
  stimesolds = stack_uuss[2]
  v *= stimesolds
  stimesolds *= s
''')
print("  %s = stack%s" % (adj_ur,adj_ur))
print("  r = grs + %s" % (adj_ur))
print("  r <<= %d" % (63-loc_ur))
print("  (int64) r >>= %d" % (63 - ni))
print("  u = fuv + %s" % (adj_ur))
print("  u <<= %d" % (63-loc_ur))
print("  (int64) u >>= %d" % (63 - ni))
print('''
  t0 = stack_uuss[0]
  t0 *= u
  rtimesoldv = stack_vvrr[0]
  u *= rtimesoldv
  rtimesoldv *= r

  s *= stack_vvrr[2]
  r *= stack_uuss[0]

  v += u
  u = t0 + t1
  r += s
  s = rtimesoldv + stimesolds

  f = stack_fxgx[0]
  g = stack_fxgx[2]
  f0 = stack_fygy[0]
  g0 = stack_fygy[2]

=? i -= 1
goto bigloop if !=
''')

print('''
# stack_FVGS*[1] and stack_FVGS*[3] are V and S, compute u V + v S
# signed modulo 2^255 - 19

int64 a4
int64 a5
int64 a6

# cneg
f0 <<= 60
g0 <<= 60
f += f0
g += g0
f *= u
g *= v
t0 = f + g
(int64) t0 >>= 60

#fuv &= 2
#t0 = 1
#t0 -= fuv
u *= t0
v *= t0

cneg:
#t0 = stack_FVGS0[0]
#t0 <<= 34
#(int64) t0 >>= 34
#u *= t0
#v *= t0


rax = stack_FVGS8[1]
# rax = V8
(int128) rdx rax = rax * u
a4 = rdx
a3 = rax

rax = stack_FVGS8[3]
# rax = S8
(int128) rdx rax = rax * v
carry? a3 += rax
       a4 += rdx + carry
# 76 bits from bit 240

a4 = (a4.a3) << 48
a3 <<= 48

rax = stack_FVGS6[1]
t0 = stack_FVGS7[1]
t0 <<= 30
rax += t0
# rax = V67
(int128) rdx rax = rax * u
t2 = rdx
t1 = rax

rax = stack_FVGS6[3]
t0 = stack_FVGS7[3]
t0 <<= 30
rax += t0
# rax = S67
(int128) rdx rax = rax * v
carry? t1 += rax
       t2 += rdx + carry
# 121 bits from bit 180

a2 = t1
t1 = (t2 t1) >> 12
a2 <<= 52
(int64) t2 >>= 12
carry? a3 += t1
       a4 += t2 + carry
       
rax = stack_FVGS4[1]
t0 = stack_FVGS5[1]
t0 <<= 30
rax += t0
# rax = V45
(int128) rdx rax = rax * u
t2 = rdx
t1 = rax

rax = stack_FVGS4[3]
t0 = stack_FVGS5[3]
t0 <<= 30
rax += t0
# rax = S45
(int128) rdx rax = rax * v
carry? t1 += rax
       t2 += rdx + carry
# 121 bits from bit 120

a1 = t1
t1 = (t2 t1) >> 8
a1 <<= 56
h = t2
(int64) t2 >>= 8
(int64) h >>= 63
carry? a2 += t1
carry? a3 += t2 + carry
       a4 += h + carry


rax = stack_FVGS2[1]
t0 = stack_FVGS3[1]
t0 <<= 30
rax += t0
# rax = V23
(int128) rdx rax = rax * u
t2 = rdx
t1 = rax

rax = stack_FVGS2[3]
t0 = stack_FVGS3[3]
t0 <<= 30
rax += t0
# rax = S23
(int128) rdx rax = rax * v
carry? t1 += rax
       t2 += rdx + carry
# 121 bits from bit 60

a0 = t1
t1 = (t2 t1) >> 4
a0 <<= 60
h = t2
(int64) t2 >>= 4
(int64) h >>= 63
carry? a1 += t1
carry? a2 += t2 + carry
carry? a3 += h + carry
       a4 += h + carry
       
rax = stack_FVGS0[1]
t0 = stack_FVGS1[1]
t0 <<= 30
rax += t0
# rax = V01
(int128) rdx rax = rax * u
t2 = rdx
t1 = rax

rax = stack_FVGS0[3]
t0 = stack_FVGS1[3]
t0 <<= 30
rax += t0
# rax = S01
(int128) rdx rax = rax * v
carry? t1 += rax
       t2 += rdx + carry
# 121 bits from bit 0
h = t2
(int64) h >>= 63
carry? a0 += t1
carry? a1 += t2 + carry
carry? a2 += h + carry
carry? a3 += h + carry
       a4 += h + carry


carry? a3 reset bit 63
a4 += a4 + carry
h = a4
rax = 19
(int128) rdx rax = rax * a4
(int64) h >>= 63
a4 = 0
carry?   a0 += rax
carry?   a1 += rdx + carry
carry?   a2 += h + carry
carry?   a3 += h + carry
         a4 += h + carry

carry? a3 reset bit 63
a4 += a4 + carry
h = a4
rax = 19
(int128) rdx rax = rax * a4
(int64) h >>= 63
carry?   a0 += rax
carry?   a1 += rdx + carry
carry?   a2 += h + carry
carry?   a3 += h + carry
         a4 += h + carry

  z = 0
a4 = -19
a5 = -1
a6 = 9223372036854775807

signed<? a3 - 0
a4 = z if !signed<
a5 = z if !signed<
a6 = z if !signed<
carry? a0 += a4
carry? a1 += a5 + carry
carry? a2 += a5 + carry
       a3 += a6 + carry

carry?   a0 += 19
carry?   a1 += 0 + carry
carry?   a2 += 0 + carry
         a3 += 0 + carry

t0 = a3
(int64) t0 >>= 63
a3 reset bit 63
t0 &= 19
carry? a0 += t0
carry? a1 += 0 + carry
carry? a2 += 0 + carry
       a3 += 0 + carry

carry?   a0 -= 19
carry?   a1 -= 0 - carry
carry?   a2 -= 0 - carry
	 a3 -= 0 - carry

# output
t2 = stack_out
''')


for i in range(4) :
    print("mem64[t2 + %2d] = a%d" % (8*i,i))

for s in caller_saved :
    print("caller_%s = stack_%s" % (s,s))

print("return")



